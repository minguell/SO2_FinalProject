#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>
#include <time.h>

#define BUFFER_SIZE 1024
#define SERVER_PORT 4000
#define DISCOVERY_PORT 4001
#define TIMEOUT 5
#define MAX_RETRIES 3 // Número máximo de tentativas de reenvio

struct message {
    int type;
    int seq_num;
    int value;
};

void send_discovery_message(int sockfd, struct sockaddr_in *server_addr);
void process_server_response(int sockfd, struct sockaddr_in *server_addr);
void send_number(int sockfd, struct sockaddr_in *server_addr, int number, int seq_num);
int handle_timeout(int sockfd, struct sockaddr_in *server_addr, int number, int seq_num);
void* send_numbers(void *arg);
void* display_status(void *arg);

int main(int argc, char *argv[]) {
    int sockfd;
    pthread_t send_thread, status_thread;

    printf("[client] Using discovery port: %d\n", DISCOVERY_PORT);

    // Cria o socket UDP
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("[client] Could not create socket");
        exit(EXIT_FAILURE);
    }

    // Configura o socket para permitir broadcast
    int broadcastEnable = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &broadcastEnable, sizeof(broadcastEnable)) < 0) {
        perror("[client] Could not enable broadcast on socket");
        exit(EXIT_FAILURE);
    }

    // Envia mensagem de descoberta
    struct sockaddr_in server_addr;
    send_discovery_message(sockfd, &server_addr);

    // Processa a resposta do servidor
    process_server_response(sockfd, &server_addr);

    // Cria uma thread para enviar números manualmente
    if (pthread_create(&send_thread, NULL, send_numbers, (void *)&sockfd) != 0) {
        perror("[client] Error creating send thread");
        exit(EXIT_FAILURE);
    }

    // Cria uma thread para exibir mensagens de status
    if (pthread_create(&status_thread, NULL, display_status, (void *)&sockfd) != 0) {
        perror("[client] Error creating status thread");
        exit(EXIT_FAILURE);
    }

    // Aguarda as threads terminarem (nunca terminam neste caso)
    pthread_join(send_thread, NULL);
    pthread_join(status_thread, NULL);

    close(sockfd);
    return 0;
}

void send_discovery_message(int sockfd, struct sockaddr_in *server_addr) {
    struct message msg;
    msg.type = 0; // Discovery type
    msg.seq_num = 0;
    msg.value = 0;

    // Configura o endereço do servidor
    memset(server_addr, 0, sizeof(*server_addr));
    server_addr->sin_family = AF_INET;
    server_addr->sin_port = htons(DISCOVERY_PORT); // Porta do servidor
    server_addr->sin_addr.s_addr = inet_addr("255.255.255.255"); // Broadcast address

    printf("[client] Sending discovery message to %s:%d\n", inet_ntoa(server_addr->sin_addr), DISCOVERY_PORT);

    // Envia a mensagem de descoberta
    if (sendto(sockfd, &msg, sizeof(msg), 0, (struct sockaddr *)server_addr, sizeof(*server_addr)) < 0) {
        perror("[client] Error sending discovery message");
        exit(EXIT_FAILURE);
    }
    printf("[client] Discovery message sent to %s:%d\n", inet_ntoa(server_addr->sin_addr), DISCOVERY_PORT);
}

void process_server_response(int sockfd, struct sockaddr_in *server_addr) {
    struct message msg;
    socklen_t addr_len = sizeof(*server_addr);

    // Aguarda a resposta do servidor
    if (recvfrom(sockfd, &msg, sizeof(msg), 0, (struct sockaddr *)server_addr, &addr_len) < 0) {
        perror("[client] Error receiving server response");
        exit(EXIT_FAILURE);
    }

    printf("[client] Server response received. Type: %d, Seq_num: %d, Value: %d\n",
           msg.type, msg.seq_num, msg.value);
}

void send_number(int sockfd, struct sockaddr_in *server_addr, int number, int seq_num) {
    struct message msg;
    msg.type = 1; // Request type
    msg.seq_num = seq_num;
    msg.value = number;

    // Envia o número ao servidor
    if (sendto(sockfd, &msg, sizeof(msg), 0, (struct sockaddr *)server_addr, sizeof(*server_addr)) < 0) {
        perror("[client] Error sending number");
        return;
    }

    printf("[client] Sent number: %d with sequence number: %d\n", number, seq_num);

    // Configura o timeout para receber a confirmação (ACK)
    if (handle_timeout(sockfd, server_addr, number, seq_num) == -1) {
        printf("[client] Failed to receive ACK after %d retries. Giving up on this message.\n", MAX_RETRIES);
    }
}

int handle_timeout(int sockfd, struct sockaddr_in *server_addr, int number, int seq_num) {
    struct message msg;
    struct timeval tv;
    fd_set readfds;
    socklen_t addr_len = sizeof(*server_addr);
    int retries = 0;

    while (retries < MAX_RETRIES) {
        // Configura o timeout
        tv.tv_sec = TIMEOUT;
        tv.tv_usec = 0;

        FD_ZERO(&readfds);
        FD_SET(sockfd, &readfds);

        // Aguarda a confirmação (ACK) do servidor
        int retval = select(sockfd + 1, &readfds, NULL, NULL, &tv);
        if (retval == -1) {
            perror("[client] Error in select");
            return -1;
        } else if (retval == 0) {
            printf("[client] Timeout, resending number: %d with sequence number: %d (Attempt %d/%d)\n", number, seq_num, retries + 1, MAX_RETRIES);
            if (sendto(sockfd, &msg, sizeof(msg), 0, (struct sockaddr *)server_addr, sizeof(*server_addr)) < 0) {
                perror("[client] Error resending number");
                return -1;
            }
            retries++;
        } else {
            if (recvfrom(sockfd, &msg, sizeof(msg), 0, (struct sockaddr *)server_addr, &addr_len) < 0) {
                perror("[client] Error receiving ACK");
                return -1;
            } else {
                printf("[client] Server ACK: Total sum = %d\n", msg.value);
                return 0;
            }
        }
    }

    return -1; // Falhou após o número máximo de tentativas
}

void* send_numbers(void *arg) {
    int sockfd = *(int *)arg;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE];
    int number;
    int seq_num = 1; // Começa em 1, como especificado no enunciado

    // Configura o endereço do servidor
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = inet_addr("255.255.255.255"); // Broadcast address

    while (1) {
        printf("[client] Enter a number to send to the server: ");
        if (fgets(buffer, BUFFER_SIZE, stdin) != NULL) {
            number = atoi(buffer);
            send_number(sockfd, &server_addr, number, seq_num++);
        }
    }

    return NULL;
}

void* display_status(void *arg) {
    int sockfd = *(int *)arg;
    struct message msg;
    struct sockaddr_in server_addr;
    socklen_t addr_len = sizeof(server_addr);

    while (1) {
        // Aguarda a confirmação (ACK) do servidor
        if (recvfrom(sockfd, &msg, sizeof(msg), 0, (struct sockaddr *)&server_addr, &addr_len) < 0) {
            perror("[client] Error receiving status message");
        } else {
            printf("[client] Server ACK: Total sum = %d\n", msg.value);
        }
    }

    return NULL;
}
